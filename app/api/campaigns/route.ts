import { type NextRequest, NextResponse } from "next/server"
import clientPromise from "@/lib/mongodb"
import type { Campaign } from "@/lib/models/Campaign"

export async function GET() {
  try {
    const client = await clientPromise
    const db = client.db("dexrooms")

    const campaigns = await db.collection<Campaign>("campaigns").find({}).sort({ createdAt: -1 }).toArray()

    return NextResponse.json({ campaigns })
  } catch (error) {
    console.error("Error fetching campaigns:", error)
    return NextResponse.json({ error: "Failed to fetch campaigns" }, { status: 500 })
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { tokenData } = body

    if (!tokenData) {
      return NextResponse.json({ error: "Token data is required" }, { status: 400 })
    }

    const client = await clientPromise
    const db = client.db("dexrooms")

    // Check if campaign already exists for this token
    const existingCampaign = await db.collection<Campaign>("campaigns").findOne({ tokenAddress: tokenData.mint })

    if (existingCampaign) {
      return NextResponse.json({ error: "Campaign already exists for this token" }, { status: 409 })
    }

    // Generate a mock escrow wallet (in production, this would be generated by your escrow system)
    const escrowWallet = `${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`

    const campaign: Campaign = {
      tokenAddress: tokenData.mint,
      name: tokenData.name,
      symbol: tokenData.symbol,
      logo: tokenData.logo,
      description: tokenData.description || `${tokenData.name} token campaign`,
      socialLinks: {
        twitter: tokenData.links?.twitter,
        website: tokenData.links?.website,
      },
      marketCap: tokenData.fullyDilutedValue,
      totalSupply: tokenData.totalSupplyFormatted,
      escrowWallet,
      raised: 0,
      goal: 300,
      contributors: 0,
      status: "active",
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 48 * 60 * 60 * 1000), // 48 hours from now
      replies: 0,
    }

    const result = await db.collection<Campaign>("campaigns").insertOne(campaign)

    return NextResponse.json({
      success: true,
      campaignId: result.insertedId,
      campaign: { ...campaign, _id: result.insertedId },
    })
  } catch (error) {
    console.error("Error creating campaign:", error)
    return NextResponse.json({ error: "Failed to create campaign" }, { status: 500 })
  }
}
